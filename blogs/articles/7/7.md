# Using brainfuck for literally no reason

### 3/8/2025

Programming languages are sure useful. But what if they weren't?

Brainfuck is an esoteric programming language created in 1993 by Urban MÃ¼ler. The language consists of 8 operators `<>+-[],.`. In this language, you are given an array of 30,000 bytes and a pointer that starts at position 0 of the array. 

The 8 operators are used to manipulate this array are:
```
> := move pointer 1 byte to the right 
< := move pointer 1 byte to the left 
+ := increase value stored at byte by 1
- := decrease value stored at byte by 1
[ := runs following code if current byte is not 0, else skip to ] 
] := jump to [ if current byte is not 0
, := input 1 character, stores in byte
. := output current byte to console (as ascii character)
```

Despite it's restrictions, Brainfuck is turing complete, which means that it is theoretically possible to write any program you can think of. 

Please note that this blog isn't an introduction to brainfuck. If you would like to learn more about the language, you can find a proper introduction here [here](https://gist.github.com/roachhd/dce54bec8ba55fb17d3a). 

## The Goal

It all started when random Discord user `pita233` built a discord bot with a command to run brainfuck code. The command would take in a brainfuck code and output stdout. However, because Discord limits 2000 characters per message, we're limited by the length of our code, and the output of our code. 

This got me thinking, given an intended output (string consisting of ascii characters), what's the minimum length of brainfuck code required to output it?

## Printing a string

Before we can run, we should learn to walk. Let's start by printing a single character 'H'. 

The `.` operator reads the current byte and outputs it in ascii, and the ascii decimal number for 'H' is 72. Trivially, we can print 'H' by incrementing the current byte to 72, and then outputting the character. 

```
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
```

We can then print a string by shifting the current byte to the next desired character, outputting it, and repeating until the message is over. A simple "Hello World!" would look like:

```brainfuck
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
+++++++++++++++++++++++++++++.
+++++++.
.
+++.
-------------------------------------------------------------------------------.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++.
++++++++++++++++++++++++.
+++.
------.
--------.
-------------------------------------------------------------------.
```

We can write a simple python program to generate this

```python
def shift_number(number): 
    sign = '-' if number < 0 else '+'
    return sign * abs(number)
    

def generate(word): 
    cur = 0
    ins = ""
    for ch in word:
        ins += shift_number(ord(ch)-cur) + "."
        cur = ord(ch) 
    return ins

if __name__ == "__main__":
    print(generate(input()))
```

However, code of this form tends to be long. We can do better by noting that there are "shorter" ways to get to a certain number. One might notice that 72 is 8*9, or in other words, 9+9+9+9+9+9+9+9+9. by utilizing index 1, we can achieve multiplication.

```brainfuck
>+++++++++[<++++++++>-]<.
```

The program moves to index 1, adds 9, then utilizes a while loop to add 8 to index 0 whilst decrementing index 1 by 1 until index 1 is 0. Lastly, it outputs the character on index 0 which is 8*9=72='H'. 

We can tremendously decrease the length of the code using this trick, but how do we do this in general? That is, how do we find the shortest line of brainfuck code to set an index of the array to a given 8bit integer?

## "Shortest" code to generate a single character

"At some point in time, computer scientists wondered to themselves: What is the best way to find the shortest path between point A and point B on a map?

By trying every single possible path of course." - Junferno

In a similar fashion, we can solve this problem by testing all possible answers, effieciently. In this section, we will use [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) to approach the problem. We will start by breaking a problem down into multiple overlapping subproblems, and solving them effieciently with [memoization](https://www.w3schools.com/dsa/dsa_ref_memoization.php).

Given a target integer, we can break the problem down recursively as such 

```
T(target) = {
    "" if target <= 0,
    "+" if target == 1,
    shortest(
        "+" * target,
        ">${T(target//factor)}[<${'+'*factor}>-]<" for all factors
    ) otherwise
}
```

The base case would be a target of 0 or 1, which is trivially "" or "+" respectively. Otherwise, we would try splitting the target 2 factors, and recursively search for ways to break down such factors. Eventually, we choose the shortest possible code from our computations.

As python code, it looks like this

```python
def shift_number(number): 
    if number <= 0: 
        return ""
        
    if number == 1: 
        return "+"

    optimal = "+"*number

    for factor in range(2, number): 
        if number % factor == 0: 
            candidate = f">{shift_number(number//factor)}[<{"+"*factor}>-]<"
            if len(candidate) < len(optimal): 
                optimal = candidate

    return optimal
```

So far, the solution relies on factoring the number, which is a problem for character like 'e' (101), which is a prime number. Instead of having 101 "+" signs, we can use `>++++++++++[<++++++++++>-]<+` instead, which is equivalent to 10*10+1. 

So now, we will upgrade our code by getting it to utilize addition as well. Note that we will be memoizing/caching our result as the search becomes quite intense.

```python
@lru_cache(maxsize=None)
def shift_number(number): 
    if number <= 0: 
        return ""

    if number == 1: 
        return "+"
        
    optimal = "+"*number

    for factor in range(2, number): 
        if number % factor == 0: 
            candidate = f">{shift_number(number//factor)}[<{"+"*factor}>-]<"
            if len(candidate) < len(optimal): 
                optimal = candidate

    for dx in range(1, number): 
        candidate = shift_number(number-dx) + shift_number(dx)
        if len(candidate) < len(optimal): 
            optimal = candidate

    return optimal
```

Note:
- Since the solution is recursive, the code may nest multiple multiplication operation.
- The result may utilize the next few spaces for multiplication. Which isn't a problem in our case as it will always leave it at 0 once it is done.
- You will need to set recursion limit to an arbitrarily large number or you encounter stackoverflow.
- The solution uses **memoization**. Utilizing [**tabulation**](https://www.geeksforgeeks.org/dsa/tabulation-vs-memoization/) will result in better performance, but I'm lazy so I won't do that.

The function generates code that completely disregards the current value at the byte, meaning that this function is more like a way to **add** to the current byte, rather than **set** the current byte. With some work, we can also get the code to **subtract** from the current byte. Then finally, we can use plug this function back to our original naive code.

```python
import sys
from functools import lru_cache
sys.setrecursionlimit(999999)

@lru_cache(maxsize=None)
def shift_number(number, decrease=False): 
    if number <= 0: 
        return ""

    sign = "-" if decrease else "+"

    if number == 1: 
        return sign

    optimal = sign*number

    for factor in range(2, number): 
        if number % factor == 0: 
            candidate = f">{shift_number(number//factor)}[<{sign*factor}>-]<"
            if len(candidate) < len(optimal): 
                optimal = candidate

    for dx in range(1, number): 
        candidate = shift_number(number-dx, decrease) + shift_number(dx, decrease)
        if len(candidate) < len(optimal): 
            optimal = candidate

    return optimal

def generate(word): 
    cur = 0
    ins = ""
    for ch in word:
        ins += shift_number(abs((s := ord(ch)-cur)), s < 0) + "."
        cur = ord(ch) 
    return ins

if __name__ == "__main__":
    print(generate(input()))
```

Using this algorithm, we can improve our original "Hello World!" code to 
```brainfuck
>+++++++++[<++++++++>-]<.
>+++++++[<++++>-]<+.
+++++++.
.
+++.
>+++++++++++++[<------>-]<-.
>+++++++++++[<+++++>-]<.
>++++++[<++++>-]<.
+++.
------.
--------.
>+++++++++++[<------>-]<-.
```

## But is this optimal?

No.

It's generally difficult to prove that an algorithm is optimal, but it's usually easy to prove that it isn't. Our Hello World code consist of 174 characters, but if we open an [online brainfuck compiler](https://www.tutorialspoint.com/compilers/online-brainfk-compiler.htm) (which has a "Hello World!" program prewritten as a template), we will find a Hello world program with 153 characters (shown below). 

```brainfuck
>+++++++++[<++++++++>-]<.
>+++++++[<++++>-]<+.
+++++++.
.
+++.
>>>++++++++[<++++>-]<.
>>>++++++++++[<+++++++++>-]<---.
<<<<.
+++.
------.
--------.
>>+.
>++++++++++.
```

We can see that on line 6 and 7, which is to print the 6th and 7th character (space and "W") respectively, the code uses index 2 and 4, instead of modifying index 0. That way, it can return to index 0 later to reuse the character o in "W**o**rld". 

Although our algorithm has an efficient way to change the byte of an index, it failed to utilize other indices, as it strictly modifies and print index 0, using the other indexes for multiplication only.

That said, it's way past my bedtime, so unfortunately, our brainfuck journey will have to end here for now. Since there is potential for improvement, I may or may not return to this project depending on whether or not I get any ideas. Goodnight World.

-Failed